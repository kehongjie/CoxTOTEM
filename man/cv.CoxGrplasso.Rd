% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.CoxGrplasso.R
\name{cv.CoxGrplasso}
\alias{cv.CoxGrplasso}
\title{Cross-validation for CoxGrplasso.

This function does K-fold cross-validation for \code{CoxGrplasso}.}
\usage{
cv.CoxGrplasso(data.list, rho = 50, iter = 100, tol = 1e-04, tlmbd, K = 5)
}
\arguments{
\item{data.list:}{A list in which every element represents a study,
typically after screening. Within each element (study), \code{time} is
the follow up time (\eqn{n \times 1}), \code{event} is the status indicator
(\eqn{n \times 1}) with 0=alive and 1=dead, and \code{X} is the covariates
matrix of dimensions \eqn{n \times p}, where p is the number of covariates
left after screening.}

\item{rho:}{The step size in ADMM algorithm. Default is 50, and change of
\code{rho} is typically not recommended.}

\item{iter:}{Maximum iterations. Default is 100.}

\item{tol:}{Convergence threshold for ADMM algorithm. Default is \code{1E-4}.}

\item{tlmbd:}{A vector of user-supplied lambda sequence.}

\item{K:}{Number of folds in cross-validation. Default is 5.}
}
\value{
A list with two elements: \code{rate} is the mean rate of successful
survival prediction for each lambda value, and \code{lambda.final} is the
optimal lambda value that maximize the mean success rate. \code{lambda.final}
can then be used in function \code{CoxGrplasso}.
}
\description{
Cross-validation for CoxGrplasso.

This function does K-fold cross-validation for \code{CoxGrplasso}.
}
\examples{
\dontrun{
set.seed(1234)
library(MASS)
library(survival)

n <- 50 ## sample size
p <- 200 ## number of covariates
rho <- 0.5
S <- 5 ## number of studies
ss <- 2 ## number of signal/true predictors
lambda0 <- 1 ## baseline hazard
rate <- 0.2 ## parameter for Exponential distribution
mu <- 1 ## signal size

## set up the coefficients
true.ind <- sample(1:p,size=ss) ## signal index
noise.ind <- (1:p)[-true.ind]
beta.mat <- matrix(0,nrow=p,ncol=S)
for(jj in 1:length(true.ind)){
  beta.mat[true.ind[jj],] <- mu
}

## simulate data for each study
data.list <- vector("list",S)
for(s in 1:S){
  beta <- beta.mat[,s]
  sigma <- toeplitz(rho^c(0,1:(p-1)))
  X <- mvrnorm(n, rep(0,p), sigma)
  U <- runif(n,0,1)
  C <- rexp(n,rate=rate)
  time <- -log(U) / (lambda0*exp(X\%*\%beta)) 
  Y <- pmin(time,C)
  D <- ifelse(time<C,1,0)
  data.list[[s]] <- list(time=Y,event=D,X=X)
}

## screening
res.SIS <- CoxSIS(data.list=data.list, alpha1=1e-4, alpha2=0.05)

## remove variables with zero coefficients
index.sis <- res.CoxSIS$index
data.list.sis <- NULL
for(s in 1:S){
 dat <- data.list[[s]]
 X <- dat[["X"]]
 X <- X[,index.sis]
 dat[["X"]] <- X
 data.list.sis[[s]] <- dat
}

## group lasso cross-validation
tlmbd <- c(30,35,38,40) ## optional lambda sequence
res.cv <- cv.CoxGrplasso(data.list.sis, rho=50, iter=100, tol=1e-4, tlmbd, K=5)
print("The rates are")
print(res.cv$rate)
print(paste("The optimal lambda is",res.cv$lambda.final))
}
}
